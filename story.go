package pg_stories

import (
	"fmt"
	"github.com/jackc/pgx/pgproto3"
	"testing"
)

// Step is the interface of every step in a Story
type Step interface {
	Step()
}

// Command is a type of Step that wraps pgproto3.FrontendMessage
type Command struct {
	pgproto3.FrontendMessage
}

// Step is here just to identify Command as a Step implementation
func (c *Command) Step() {}

// Response is a type of Step that wraps pgproto3.BackendMessage
type Response struct {
	pgproto3.BackendMessage
}

// Step is here just to identify Command as a Step implementation
func (r *Response) Step() {}

// Compare checks if the value of the provided msg equals to the underlying BackendMessage.
// In some cases it performs deep compare.
func (r *Response) Compare(msg pgproto3.BackendMessage) error {
	expectedRaw := r.BackendMessage.Encode([]byte{})
	actualRaw := msg.Encode([]byte{})
	if len(expectedRaw) == 0 {
		return fmt.Errorf("invalid message expected")
	}
	if len(actualRaw) == 0 {
		return fmt.Errorf("invalid message received")
	}
	if expectedRaw[0] != actualRaw[0] {
		return fmt.Errorf("wrong type of message. expected: %T. got %T", r.BackendMessage, msg)
	}

	switch r.BackendMessage.(type) {
	case *pgproto3.ErrorResponse:
		expectedCode := r.BackendMessage.(*pgproto3.ErrorResponse).Code
		actualCode := msg.(*pgproto3.ErrorResponse).Code
		if expectedCode != "" && expectedCode != actualCode {
			return fmt.Errorf("expected error response with code: %s. got %s", expectedCode, actualCode)
		}
	}

	return nil
}

// Story holds a sequence of Step and uses pgproto3.Frontend to communicate with the tested backend.
type Story struct {
	// Frontend is the component that communicates with the tested backend
	Frontend *pgproto3.Frontend
	// Steps is a sequence of Step that defines a story
	Steps []Step
	// Filter is a function that tells the runner which types of responses it should verify
	Filter func(pgproto3.BackendMessage) bool
}

// Run is running the Steps and fails the provided t on error. Because it uses go routines
// and waits infinitely for expected responses, it also listens the provided chan for kill signals.
// Most common use of c is a timeout error that should be generated by the caller of Run.
func (s *Story) Run(t *testing.T, c <-chan interface{}) (err error) {

	success := make(chan bool)
	errors := make(chan error)
	responseBuffer := make(chan pgproto3.BackendMessage, 100)

	go func() {
		for {
			b, err := s.Frontend.Receive()
			if err != nil {
				errors <- err
				return
			}
			if s.Filter == nil || s.Filter(b) {
				responseBuffer <- b
			}
		}
	}()

	go func() {
		for _, step := range s.Steps {
			var e error
			switch step.(type) {
			case *Command:
				if len(responseBuffer) > 0 {
					e = fmt.Errorf("backend messages exist in buffer")
					break
				}
				msg := step.(*Command).FrontendMessage
				t.Logf("==>> %#v\n", msg)
				e = s.Frontend.Send(msg)
			case *Response:
				msg := <-responseBuffer
				t.Logf("<<== %#v\n", msg)
				e = step.(*Response).Compare(msg)
			}
			if e != nil {
				errors <- e
				return
			}
		}
		if len(responseBuffer) > 0 {
			errors <- fmt.Errorf("expected missing step for: %#v", <-responseBuffer)
			return
		}
		success <- true
	}()

	select {
	case e := <-errors:
		err = e
		break
	case <-success:
		break
	case v := <-c:
		err = fmt.Errorf("received stop signal %#v", v)
		break
	}

	return
}
